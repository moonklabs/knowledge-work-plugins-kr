---
description: 연결된 모든 소스를 하나의 검색 쿼리로 검색합니다
argument-hint: "<검색 쿼리>"
---

# Search 커맨드

> 익숙하지 않은 플레이스홀더가 보이거나 연결된 도구를 확인하려면 [CONNECTORS.md](../CONNECTORS.md)를 참조하세요.

연결된 모든 MCP 소스를 하나의 검색 쿼리로 검색합니다. 사용자의 질문을 분해하고 병렬 검색을 실행한 후 결과를 통합합니다.

## 지침

### 1. 사용 가능한 소스 확인

검색 전에 사용 가능한 MCP 소스를 확인합니다. 사용 가능한 도구 목록에서 연결된 도구를 식별합니다. 일반적인 소스:

- **~~chat** — 채팅 플랫폼 도구
- **~~email** — 이메일 도구
- **~~cloud storage** — 클라우드 스토리지 도구
- **~~project tracker** — 프로젝트 트래킹 도구
- **~~CRM** — CRM 도구
- **~~knowledge base** — 지식 베이스 도구

연결된 MCP 소스가 없는 경우:
```
도구 통합 검색을 사용하려면 최소 하나 이상의 소스를 연결해야 합니다.
MCP 설정에서 ~~chat, ~~email, ~~cloud storage 또는 기타 도구를 추가했는지 확인하세요.

지원되는 소스: ~~chat, ~~email, ~~cloud storage, ~~project tracker, ~~CRM, ~~knowledge base,
그리고 기타 모든 MCP 연결 서비스.
```

### 2. 사용자 쿼리 파싱

검색 쿼리를 분석하여 다음을 파악합니다:

- **의도**: 사용자가 무엇을 찾고 있는가? (의사결정, 문서, 사람, 상태 업데이트, 대화)
- **엔티티**: 언급된 사람, 프로젝트, 팀, 도구
- **시간 제약**: 최신성 신호 ("이번 주", "지난 달", 특정 날짜)
- **소스 힌트**: 특정 도구에 대한 참조 ("~~chat에서", "그 이메일", "그 문서")
- **필터**: 쿼리에서 명시적 필터를 추출:
  - `from:` — 발신자/작성자로 필터
  - `in:` — 채널, 폴더 또는 위치로 필터
  - `after:` — 이 날짜 이후의 결과만
  - `before:` — 이 날짜 이전의 결과만
  - `type:` — 콘텐츠 유형으로 필터 (메시지, 이메일, 문서, 스레드, 파일)

### 3. 하위 쿼리로 분해

사용 가능한 각 소스에 대해 해당 소스의 기본 검색 구문을 사용하여 맞춤 하위 쿼리를 생성합니다:

**~~chat:**
- 채팅 플랫폼의 사용 가능한 검색 및 읽기 도구를 사용합니다
- 필터 변환: `from:`은 발신자에, `in:`은 채널/방에, 날짜는 시간 범위 필터에 매핑됩니다
- 적절한 경우 시맨틱 검색에 자연어 쿼리를 사용합니다
- 정확한 일치를 위해 키워드 쿼리를 사용합니다

**~~email:**
- 사용 가능한 이메일 검색 도구를 사용합니다
- 필터 변환: `from:`은 발신자에, 날짜는 시간 범위 필터에 매핑됩니다
- `type:`은 첨부파일 필터나 제목줄 검색에 적절히 매핑합니다

**~~cloud storage:**
- 사용 가능한 파일 검색 도구를 사용합니다
- 파일 쿼리 구문으로 변환: 이름 포함, 전문 검색, 수정 날짜, 파일 유형
- 파일 이름과 콘텐츠를 모두 고려합니다

**~~project tracker:**
- 사용 가능한 작업 검색 또는 자동 완성 도구를 사용합니다
- 작업 텍스트 검색, 담당자 필터, 날짜 필터, 프로젝트 필터에 매핑합니다

**~~CRM:**
- 사용 가능한 CRM 쿼리 도구를 사용합니다
- Account, Contact, Opportunity 및 기타 관련 객체를 검색합니다

**~~knowledge base:**
- 개념적 질문에는 시맨틱 검색을 사용합니다
- 정확한 일치에는 키워드 검색을 사용합니다

### 4. 병렬 검색 실행

사용 가능한 모든 소스에서 모든 하위 쿼리를 동시에 실행합니다. 하나의 소스를 기다린 후 다른 소스를 검색하지 않습니다.

각 소스에 대해:
- 변환된 쿼리를 실행합니다
- 메타데이터(타임스탬프, 작성자, 링크, 소스 유형)와 함께 결과를 캡처합니다
- 실패하거나 오류를 반환하는 소스를 기록합니다 — 하나의 실패가 다른 소스를 차단해서는 안 됩니다

### 5. 순위 지정 및 중복 제거

**중복 제거:**
- 여러 소스에서 나타나는 동일한 정보를 식별합니다 (예: ~~chat에서 논의되고 이메일로 확인된 의사결정)
- 중복을 표시하는 대신 관련 결과를 함께 그룹화합니다
- 가장 신뢰할 수 있거나 완전한 버전을 우선합니다

**순위 요인:**
- **관련성**: 결과가 쿼리 의도와 얼마나 잘 일치하는가?
- **최신성**: 상태/의사결정 쿼리의 경우 최근 결과가 더 높은 순위를 받습니다
- **신뢰도**: 사실 관련 질문의 경우 공식 문서 > 위키 > 채팅 메시지; "무엇을 논의했는가" 쿼리의 경우 대화 > 문서
- **완전성**: 더 많은 컨텍스트를 가진 결과가 더 높은 순위를 받습니다

### 6. 통합 결과 표시

응답을 원시 결과 목록이 아닌 통합된 답변으로 형식화합니다:

**사실/의사결정 쿼리의 경우:**
```
[질문에 대한 직접적인 답변]

출처:
- [출처 1: 간단한 설명] (~~chat, #채널, 날짜)
- [출처 2: 간단한 설명] (~~email, 보낸사람, 날짜)
- [출처 3: 간단한 설명] (~~cloud storage, 문서명, 최종 수정일)
```

**탐색적 쿼리의 경우 ("X에 대해 무엇을 알고 있는가"):**
```
[모든 출처의 정보를 종합한 요약]

발견된 위치:
- ~~chat: Y개 채널에서 X개의 관련 메시지
- ~~email: X개의 관련 스레드
- ~~cloud storage: X개의 관련 문서
- [기타 해당 출처]

주요 출처:
- [링크/참조가 있는 가장 중요한 출처]
- [두 번째로 중요한 출처]
```

**"찾기" 쿼리의 경우 (특정 항목 검색):**
```
[직접 참조와 함께 찾는 항목]

다음도 발견됨:
- [다른 출처의 관련 항목]
```

### 7. 엣지 케이스 처리

**모호한 쿼리:**
쿼리가 여러 의미를 가질 수 있는 경우, 검색 전에 하나의 명확화 질문을 합니다:
```
"API 재설계"는 몇 가지 다른 의미일 수 있습니다. 다음 중 어떤 것을 찾으시나요?
1. REST API v2 재설계 (Project Aurora)
2. 내부 SDK API 변경 사항
3. 기타 다른 내용
```

**결과 없음:**
```
[검색된 소스 목록]에서 "[query]"와 일치하는 항목을 찾을 수 없습니다.

다음을 시도해 보세요:
- 더 포괄적인 용어 (예: "PostgreSQL 마이그레이션" 대신 "데이터베이스")
- 다른 시간 범위 (현재 검색 범위: [시간 범위])
- 관련 소스가 연결되어 있는지 확인 (현재 검색 중인 소스: [소스])
```

**부분 결과 (일부 소스 실패):**
```
[성공한 소스의 결과]

참고: 이번 검색 중 [실패한 소스]에 연결할 수 없었습니다.
위 결과는 [성공한 소스]의 정보만 포함하고 있습니다.
```

## 참고 사항

- 항상 여러 소스를 병렬로 검색합니다 — 순차적으로 검색하지 않습니다
- 원시 검색 결과를 나열하지 말고 답변으로 통합합니다
- 사용자가 더 깊이 파고들 수 있도록 출처를 표시합니다
- 사용자의 필터 구문을 존중하고 소스별로 적절하게 적용합니다
- 쿼리에서 특정 사람을 언급하면 모든 소스에서 해당 사람의 메시지/문서/멘션을 검색합니다
- 시간에 민감한 쿼리의 경우 순위에서 최신성을 우선합니다
- 하나의 소스만 연결되어 있더라도 해당 소스에서 유용한 결과를 제공합니다
